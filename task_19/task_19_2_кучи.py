# def strategy(s_1, s_2, prev_n, n):      #s_1 - количество камней 1 кучи / s_2 - количество камней  2 кучи/ prev_n - количество СОВЕРШЕННЫХ ходов /n - количество ходов
#     if s_1 + s_2 <= 20:         # игра завершилась ровно или менее prev_n ходов
#         return prev_n % 2 == n % 2
#     if prev_n == n:             # ходов больше нет
#         return 0
#     variants = [strategy(s_1 - 1, s_2,  prev_n + 1, n),
#                 strategy(s_1, s_2 - 1, prev_n + 1, n),
#                 strategy(s_1 // 2, s_2,  prev_n + 1, n),
#                 strategy(s_1, s_2 // 2, prev_n + 1, n)]
#     return any(variants) if (prev_n + 1) % 2 == n % 2 else all(variants)
#
# print('19: ', [s for s in range(10, 20) if strategy(10, s, 0, 2)] )
# print('20: ', [s for s in range(1, 70) if not strategy(7, s,0, 1) and strategy(7, s,0, 3)] )
# print('21: ', [s for s in range(1, 70) if not strategy(7, s, 0, 2) and strategy(7, s, 0, 4)] )

# def strategy(s_1 , s_2, prev_n, n):
#     if s_1 + s_2 <= 20:
#         return prev_n % 2 == n % 2
#     if prev_n == n:
#         return 0
#     if s_1 % 2 != 0:
#         s_1_h = s_1 // 2 + 1
#     else:
#         s_1_h = s_1 // 2
#
#     if s_2 % 2 != 0:
#         s_2_h = s_2 // 2 + 1
#     else:
#         s_2_h = s_2 // 2
#     variants = [strategy(s_1 - 1, s_2,  prev_n + 1, n),
#                 strategy(s_1, s_2 - 1, prev_n + 1, n),
#                 strategy(s_1_h, s_2,  prev_n + 1, n),
#                 strategy(s_1, s_2_h, prev_n + 1, n)]
#     return any(variants) if (prev_n + 1) % 2 == n % 2 else all(variants)
#
# print('19: ', [s for s in range(11, 100) if strategy(10, s, 0, 2)] )
# print('20: ', [s for s in range(11, 100) if not strategy(7, s,0, 1) and strategy(7, s,0, 3)] )

# Два игрока, Петя и Ваня, играют в следующую игру. Перед игроками лежат две кучи камней.
# Игроки ходят по очереди, первый ход делает Петя. За один ход игрок может добавить в одну
# из куч один камень или увеличить количество камней в куче в два раза. Чтобы делать ходы,
# у каждого игрока есть неограниченное количество камней. Игра завершается в тот момент,
# когда суммарное количество камней в кучах становится не менее 69.
# Победителем считается игрок, сделавший последний ход, т. е. первым получивший позицию,
# в которой в кучах будет 69 или больше камней.
# В начальный момент в первой куче было 5 камней, во второй куче – S камней, 1 ≤ S ≤ 63.
# Будем говорить, что игрок имеет выигрышную стратегию, если он может выиграть при любых ходах противника.
# Ответьте на следующие вопросы:
#
# Вопрос 1. Известно, что Ваня выиграл своим первым ходом после
# неудачного первого хода Пети. Назовите минимальное значение S, при котором это возможно.
# Петя - 1 ход
# Ходы - ПВ
# step = 1 - начало игры
# step = 2 - Петя
# step = 3 - Ваня
# step = 4 - Петя
# step = 5 - Ваня


# Вопрос 2. Найдите два таких значения S, при которых у Пети есть
# выигрышная стратегия, причём Петя не может выиграть первым ходом,
# но может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
# Найденные значения запишите в ответе в порядке возрастания.
# Петя - 1 ход
# Ходы - ПВ
# step = 1 - начало игры
# step = 2 - Петя
# step = 3 - Ваня
# step = 4 - Петя
# step = 5 - Ваня

# Вопрос 3. Укажите минимальное значение S, при котором у Вани есть
# выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом
# при любой игре Пети, и при этом у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
#
# Петя - 1 ход
# Ходы - ПВ
# step = 1 - начало игры
# step = 2 - Петя
# step = 3 - Ваня
# step = 4 - Петя
# step = 5 - Ваня

#19
# def simpleFunc(s_1, s_2, step):
#     if s_1 + s_2 < 69 and step == 3:        #ход Вани но камней мало - проигрыш
#         return False
#     elif s_1 + s_2  >=69 and step == 3:     #ход Вани и камней нужное количество - выигрыш
#         return True
#     elif s_1 + s_2  >=69 and step < 3:     #ход НЕ Вани и камней нужное количество - выигрыш НЕ у вани
#         return False
#     return simpleFunc(s_1 + 1, s_2, step + 1) or simpleFunc(s_1, s_2 + 1, step + 1) or simpleFunc(s_1 * 2, s_2, step + 1) or simpleFunc(s_1, s_2 * 2, step + 1)
#
# print('19: ', [s for s in range(1, 64) if simpleFunc(5, s, 1)])

# #20
# def simpleFunc(s_1, s_2, step):
#     if s_1 + s_2  >=69 and step == 4:
#         return True
#     elif s_1 + s_2 < 69 and step == 4:
#         return False
#     elif s_1 + s_2  >=69 and step < 4:
#         return False
#
#     if step % 2 == 1:   #ходы ВАНИ
#         return simpleFunc(s_1 + 1, s_2, step + 1) or simpleFunc(s_1, s_2 + 1, step + 1) or simpleFunc(s_1 * 2, s_2, step + 1) or simpleFunc(s_1, s_2 * 2, step + 1)
#     else:   #ходы ПЕТИ
#         return simpleFunc(s_1 + 1, s_2, step + 1) and simpleFunc(s_1, s_2 + 1, step + 1) and simpleFunc(s_1 * 2, s_2, step + 1) and simpleFunc(s_1, s_2 * 2, step + 1)
#
# print('20: ', [s for s in range(1, 64) if simpleFunc(5, s, 1)])


#21
# def simpleFunc(s_1, s_2, step):
#     if s_1 + s_2  >=69 and (step == 3  or step == 5):
#         return True
#     elif s_1 + s_2 < 69 and step == 5:
#         return False
#     elif s_1 + s_2  >=69 and step < 5:
#         return False
#
#     if step % 2 == 0:   #ходы ПЕТИ
#         return simpleFunc(s_1 + 1, s_2, step + 1) or simpleFunc(s_1, s_2 + 1, step + 1) or simpleFunc(s_1 * 2, s_2, step + 1) or simpleFunc(s_1, s_2 * 2, step + 1)
#     else:   #ходы ВАНИ
#         return simpleFunc(s_1 + 1, s_2, step + 1) and simpleFunc(s_1, s_2 + 1, step + 1) and simpleFunc(s_1 * 2, s_2, step + 1) and simpleFunc(s_1, s_2 * 2, step + 1)
#
# print('21: ', [s for s in range(1, 64) if simpleFunc(5, s, 1)])


#120)(А. Богданов) Два игрока, Петя и Ваня, играют в следующую игру.
# Перед игроками лежит две кучи камней. Игроки ходят по очереди,
# первый ход делает Петя. За один ход игрок может убрать из любой
# кучи один или три камня. Игра завершается в тот момент, когда
# количество камней в любой из куч становится менее 10. Победителем
# считается игрок, сделавший последний ход, т.е. первым получивший кучу,
# в которой меньше 10 камней. Будем говорить, что игрок имеет выигрышную
# стратегию, если он может выиграть при любых ходах противника.
# Задание 19.
# В начальный момент в кучах было по S камней. Найдите такое значение S,
# при котором Петя не может выиграть за один ход, но при любом ходе Пети Ваня может выиграть своим первым ходом.
# Задание 20.
# Известно, что в первой куче 13 камней, а во второй – S камней (S ≥ 10).
# Найдите наименьшее и наибольшее значения S, при которых у Пети есть выигрышная стратегия, причём одновременно выполняются два условия:
#     – Петя не может выиграть за один ход;
#     – Петя может выиграть своим вторым ходом независимо от того, как будет ходить Ваня.
# Запишите в ответе сначала наименьшее значение, потом – наибольшее.
# Задание 21
# Известно, что в первой куче 13 камней, а во второй – S камней (S ≥ 10).
# Найдите наименьшее и наибольшее значения S, при котором одновременно выполняются два условия:
# — у Вани есть выигрышная стратегия, позволяющая ему выиграть первым или вторым ходом при любой игре Пети;
# — у Вани нет стратегии, которая позволит ему гарантированно выиграть первым ходом.
# Запишите в ответе сначала наименьшее значение, потом – наибольшее.

def  simpleFunc (s_1,s_2, step):
    if s_2 < 0 or s_1 < 0:
        return False
    elif  (s_2 <= 10 or s_1 <= 10) and (step == 3 or step == 5):
        return True
    elif (s_2 > 10  or s_1 > 10) and step == 5:
        return False
    elif (s_2 <= 10 or s_1 <= 10) and step < 5:
        return False

    if step % 2 == 0 :
        return simpleFunc(s_1 - 1, s_2,  step +  1 ) or  simpleFunc(s_1 -  3, s_2,  step +  1 ) or  simpleFunc (s_1 , s_2 - 1,  step +  1 ) or  simpleFunc (s_1 , s_2 - 3,  step +  1 )
    else:
        return simpleFunc(s_1 - 1, s_2, step + 1) and simpleFunc(s_1 -  3, s_2,  step +  1 ) and  simpleFunc (s_1 , s_2 - 1,  step +  1 ) and  simpleFunc (s_1 , s_2 - 3,  step +  1 )

print('21: ', [s for s in range(10, 1000) if simpleFunc(13, s, 1)])